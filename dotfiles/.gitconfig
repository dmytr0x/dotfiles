# Credits:
# - https://blog.gitbutler.com/how-git-core-devs-configure-git/
# - https://github.com/ohmyzsh/ohmyzsh/blob/master/plugins/git/git.plugin.zsh
#

[core]
  editor = hx
  pager = delta
  excludesfile = ~/.gitignore_global

[init]
	defaultBranch = main

[branch]
  # New branches created from a remote-tracking branch will default to --rebase instead of merge
  # Now `git pull` on a branch will rebase by default
  autoSetupRebase = always
  # Sort by each branch’s most recent commit’s committer date. The minus means "descending" (newest first)
  sort = -committerdate

[tag]
  sort = version:refname

[color]
  # Turn on colored output for status, diff, branch, etc.
  ui = auto

[log]
  # Formats dates. Options: “iso”, “relative”, “local”, etc.
  date = iso

[fetch]
  # Automatically prunes deleted remote branches
  prune = true
  #
  pruneTags = true
  #
  all = true

[rerere]
  # Turns on Git’s “reuse recorded resolution” feature (rerere)
  # Whenever you resolve a merge or rebase conflict by hand, Git saves (“records”) your final resolution in `.git/rr-cache`
  # If the same conflict (i.e. the same conflicted hunk) shows up again—say you rebase, cherry-pick, or merge another branch
  # that hits the same lines, Git will automatically replay ("reuse") your prior resolution for you
  enabled = true
  # After rerere finds and applies a recorded resolution in your working tree, Git will immediately git add that file for you ("autoupdate" the index)      
  autoupdate = true

[rebase]
  # Shows a summary of changes (insertions/deletions) as part of an interactive rebase
  # You’ll see a handy diffstat after each replayed commit
  # ?
  stat = true
  # Git to automatically “squash” or “fixup” your fixup!/squash! commits into their target commits when you run an interactive rebase
  # Whenever you create a fixup or squash commit with:
  #  - git commit --fixup=<commit>
  #  - git commit --squash=<commit>
  # will automatically:
  #  - Move those fixup!/squash! commits directly below their target commit
  #  - Change their action from `pick` to `fixup` (or `squash`) in the todo list
  # or manually:
  # git rebase -i --autosquash <base>
  autoSquash = true

[merge]
  # Always show a diffstat at the end of a merge
  stat = true
  # Gives more context when merging or rebasing by showing the common ancestor
  #   Exactly like `diff3`, but with zero lines of context around each conflict
  conflictStyle = zdiff3

[mergetool]
  prompt = false

[diff]
  # Use mnemonic prefixes (index, work tree, commit, object) instead of the standard a and b notation
  mnemonicprefix = true
  # Highlights blocks of code that have been moved, not just added/removed
  colorMoved = default
  # It tells Git to spend extra time searching for the absolutely smallest set of insertions and deletions that explain your changes
  algorithm = histogram
  # This algorithm merges nearby hunks, creating more compact and readable diffs by reducing noise and expanding context
  compactionHeuristic = true
  # Use `a/` and `b/` in diffs to indicate "before" and "after" instead of the default file paths
  # – "a/" and "b/" when you’re diffing two commits
  # – "c/" and "i/" when you’re diffing HEAD (the last commit) vs the index (the staging area)
  # – "i/" and "w/" when you’re diffing the index vs the working tree
  # – "c/" and "w/" when you do something that compares HEAD vs the working tree in one go
  mnemonicPrefix = true
  # Git will try to detect renamed (or moved) files when you run diff-based commands (diff, log, show, status, etc.)
  renames = true

[difftool]
  prompt = false

[grep]
  lineNumber = true
  fullname = true

[commit]
  # Include the diff of staged changes at the bottom of your editor when writing a commit message
  verbose = true

[push]
  # The first time you git push a new branch, it automatically sets upstream tracking
  autoSetupRemote = true

[pager]
  # Will never invoke a pager for ...
  # Under the hook these lines are equivalent to
  #   git --no-pager branch
  #   git --no-pager tag
  #
  # If you ever want to override your config and force paging for just one run
  #   git --paginate branch
  #   git --paginate tag
  # 
  branch = false
  tag = false

[alias]
  branch-name = !git rev-parse --abbrev-ref HEAD

  st = status --short
  cm = commit
  ch = checkout
  br = branch
  df = diff
  dft = difftool
  mt = mergetool
  sw = switch

  ll = log --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit
  hist = ll --graph --decorate
  lls = ll --numstat
  llg = ll -E -i --grep

  bch = !git branch | fzf | xargs git checkout
  bll = !git ll master..$(git branch-name)
  bdf = !git diff master $(git branch-name)
  bp = !git push origin $(git branch-name)
  bpf = !git push --force-with-lease origin $(git branch-name)

  undo = !git reset --hard HEAD^
  uncommit = !git reset --mixed HEAD^
  unstage = !git reset

  # Commits everything in my working directory and then does a hard reset to remove that commit.
  # You can reach that commit later in 'git reflog'
  wipe = !git add -A && git commit --no-verify -qm 'WIPE SAVEPOINT' && git reset HEAD~1 --hard

  # List every author who has contributed to the current branch (since its root)
  # and next to each name print how many commits they’ve made
  who = shortlog -s --

[interactive]
  diffFilter = delta --color-only

[delta]
  # use n and N to move between diff sections
  navigate = true
  #
  features = line-numbers decorations
  #
  side-by-side = true

# Include the personal config
[includeIf "gitdir:~/"]
  path = ~/.gitconfig_local
